# 5.7: アイデンティティの考察：エンティティ
エンティティと値オブジェクトの違い　⇒　固有のアイデンティティを持つか否か<br>
* 固有のアイデンティティを持つ　⇒　エンティティ
* 固有のアイデンティティを持たない　⇒　値オブジェクト

「値オブジェクトと」「エンティティ」の違いは文脈によって異なる。<br>
（例）
TODO：例書く

## 5.7.1: エンティティの識別子
* エンティティは固有のアイデンティティ（**識別子**）を持つ必要がある<br>
* 識別子は不変である必要がある
（例）携帯の連絡先<br>
以下はContractID（連絡先ID）を識別子とする型。
電話番号やEmailアドレスなどから構成されるが、それらが変わっても連絡先IDは変わらない

```
type ContactId = ContractId of int

type Contact = {
    ContactId : ContactId
    PhoneNumber : ...
    EmailAddress : ...
}
```


## 5.7.2: データ定義への識別子の追加
識別子を型に付与する方法は2種類
* 外から付与
* 内から付与

### 外から付与
（例）支払い情報エンティティ（未払いと支払い済みでエンティティを分ける場合）
```
// 識別子を定義
type InvoiceId = ...

// 個々の支払いエンティティを定義
// この時点では識別子は付与しない
type UnpaidInvoiceInfo = ...
type PaidInvoiceInfo = ...

// 支払いエンティティをOR型で表現
type InvoiceInfo =
  | Unpaid of UnpaidInvoiceInfo
  | Paid of PaidInvoiceInfo

// 支払いエンティティにIDを付与
type Invoice = {
  InvoiceId: InvoiceId
  InvoiceInfo: InvoiceInfo
}
```

### 内から付与（推し）
（例）支払い情報エンティティ（未払いと支払い済みでエンティティを分ける場合）
```
// 識別子を定義
type InvoiceId = ...

// 個々の支払いエンティティを定義
// 識別子を個々のエンティティの中で指定
type UnpaidInvoiceInfo = {
  InvoiceId: InvoiceId
}
type PaidInvoiceInfo  = {
  InvoiceId: InvoiceId
}

// 支払いエンティティをOR型で表現
type Invoice =
  | Unpaid of UnpaidInvoiceInfo
  | Paid of PaidInvoiceInfo
```

* メリット
  * パターンマッチの際に一度でアクセスできる

## 5.7.3: エンティティに対する等値性の実装
エンティティは「**識別子が同じ = 同一のエンティティ**」とみなすことができる
（例）引っ越し前と後で、住む場所は違っても同じ人間

つまり「オブジェクト同士を比較しても意味がないので、**エンティティを比較する際は常に識別子を使用するように実装したい**」というのがこの節の話

```

```

## 5.7.4: 不変性とアイデンティティ
不変性（immutable）が求められるのはどちら？
* 値オブジェクト
* エンティティ

F#などの関数型プログラミング言語では、値はデフォルトで不変（immutable）になる。
では、エンティティの値を変更したい際はどうするか、、、
　⇒　コピーを作成する

```
// ある値を用意（不変。変更不可。）
let initialPerson = {PersonId=PersonId 42; Name="Joseph"}

// コピーを作成
// withを使って一部の値を変更できる
let updatedPerson = {initialPerson with Name="Joe"}
```

* メリット
  * 変更があった場合、型シグネチャで明示しなければならないので分かりやすい

```
// UpdateNameの中で値を変更する場合、返却型をunitにはできない
type UpdateName = Person -> Name -> unit

// PersonのNameが更新されることが想像しやすい
type UpdateName = Person -> Name -> Person
```

