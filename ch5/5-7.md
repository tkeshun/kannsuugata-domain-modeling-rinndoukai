# 5.7: アイデンティティの考察：エンティティ
エンティティと値オブジェクトの違いは「**固有のアイデンティティを持つか否か**」<br>
* 固有のアイデンティティを持つ　⇒　エンティティ
* 固有のアイデンティティを持たない　⇒　値オブジェクト

> [!TIP]
> 「値オブジェクト」と「エンティティ」の区別は文脈に依存する<br>
> <br>
> * 例）携帯電話は「値オブジェクト」？「エンティティ」？
>   * 製造段階　⇒　固有のシリアル番号が付与されるので「エンティティ」
>   * 販売時　　⇒　同じ型であればシリアル番号は気にしないので「値オブジェクト」

## 5.7.1: エンティティの識別子
エンティティは固有のアイデンティティ（**識別子**）を持つ必要がある<br>

例）携帯の連絡先<br>
* 電話番号やEmailアドレスなどから構成されるが、それらが変わっても連絡先IDは変わらない

```Go
// メールアドレスが変わっても、ContractIdは変わらない
type Contact struct {
    ContactId ContactId
    PhoneNumber PhoneNumber
    EmailAddress EmailAddress
}
```


## 5.7.2: データ定義への識別子の追加
識別子を型に付与する方法は2種類
* 外から付与
* 内から付与

### 外から付与
例）支払い情報エンティティ（未払いと支払い済みでエンティティを分ける場合）
```Go
// 識別子を定義
type InvoiceId int

// 個々の支払いエンティティを定義
// この時点では識別子は付与しない
type UnpaidInvoiceInfo struct {
    ~~
}
type PaidInvoiceInfo struct {
    ~~
}

// 支払いエンティティをInterfaceで表現
// Interfaceの実装は割愛
type InvoiceInfo interface {
    ~~
}

// 支払いエンティティにIDを付与
type Invoice = {
    InvoiceId InvoiceId
    InvoiceInfo InvoiceInfo  // UnpaidInvoiceInfo と PaidInvoiceInfo のどちらか
}
```

### 内から付与（推し）
例）支払い情報エンティティ（未払いと支払い済みでエンティティを分ける場合）
```Go
// 識別子を定義
type InvoiceId int

// 個々の支払いエンティティを定義
// 識別子を個々のエンティティの中で指定
type UnpaidInvoiceInfo struct {
    InvoiceId InvoiceId
}
type PaidInvoiceInfo struct {
    InvoiceId InvoiceId
}

// 支払いエンティティをInterfaceで表現
// UnpaidInvoiceInfo と PaidInvoiceInfo のどちらか
type Invoice interface {
    ~~
}
```

* メリット
  * パターンマッチの際に一度でアクセスできる

## 5.7.3: エンティティに対する等値性の実装
エンティティは「**識別子が同じ = 同一のエンティティ**」とみなすことができる<br>
例）引っ越し前と後で、住む場所は違っても同じ人間<br>
<br>
つまり「**エンティティを比較する際は常に識別子を使用するように実装したい**」というのがこの節の話<br>


## 5.7.4: 不変性とアイデンティティ
不変性（immutable）が求められるのはどちら？
* 値オブジェクト
* エンティティ

F#などの関数型プログラミング言語では、値はデフォルトで不変（immutable）になる。<br>
では、エンティティの値を変更したい際はどうするか、、、<br>
　⇒　コピーを作成する<br>

```F#
// ある値を用意（不変。変更不可。）
let initialPerson = {PersonId=PersonId 42; Name="Joseph"}

// コピーを作成
// withを使って一部の値を変更できる
let updatedPerson = {initialPerson with Name="Joe"}
```

* メリット
  * 変更があった場合、型シグネチャで明示しなければならないので分かりやすい
```F#
// UpdateNameの中で値を変更する場合、返却型をunitにはできない
type UpdateName = Person -> Name -> unit

// PersonのNameが更新されることが想像しやすい
type UpdateName = Person -> Name -> Person
```


※Goではimmutableな型を作成することができないようなので、↑のような心配は不要。

```Go
// voidにする場合は参照渡しにすれば、一応明示的に更新を示せる
func updateName(p *Person, name string) {
    p.Name = name
}

// 参照渡しにせず、返却値の型で定義したほうが明確
func updateName(p Person, name string) Person {
    p.Name = name
    return p
}
```

