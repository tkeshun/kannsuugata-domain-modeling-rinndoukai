## 5-3 単純な値のモデリング

- ドメインエキスパートはドメインで概念で考えている
- OrderIdとProductCodeが混同されないようにすることが重要
	- 仮に両方intで表されても互換性はない
	- 型が異なることを明確にするために「ラッパー型」を作る
- ラッパー型を作成する簡単な方法 → F#では単一ケースの共用体（選択肢が1つしかない選択型）
	- Goでは型定義で表現する

F#の場合
```F#
type CustomerId = CustomerId of int
type WidgetCode = WidgetCode of string
type UnitQuantity = UnitQuantity of int
type KilogramQuantity = KilogramQuantity of decimal
```

上記のラッパー型を「単純型」と呼び、複合型（レコードなど）やそれらが含んでいる生のプリミティブ型と区別している。

Goの場合
```Go
type CustomerId int
type WidgetCode string
type UnitQuantity int
// decimalがGoの標準では存在しないため、shopspring/decimal ライブラリを使用する
type KilogramQuantity decimal.Decimal
```
### 5.3.1 単一ケース共用体の利用

#### 値の作成
F#の場合
```F#
type CustomerId = CustomerId of int
let customerId = CustomerId 42
```
Goの場合
```Go
type CustomerId int
var customerId CustomerId = 1
```
#### 異なる型同士の比較
F#の場合
```F#
type CustomerId = CustomerId of int
type OrderId = OrderId of int

let customerId = CustomerId 42
let orderId = OrderId 42

printfn "%d" (orderId = customerId) // 型が異なるためコンパイルエラー
```
Goの場合
```Go
type CustomerId int 
type OrderId int 

var customerId CustomerId = 1 
var orderId OrderId = 1 
fmt.Printf("%t\n", orderId == customerId) // 型が異なるためコンパイルエラー
```
#### 異なる型の値を渡した関数
F#の場合
```F#
// CustomerIdを使う関数を定義
let processCustomerId (id:CustomerId) = ...

// OrderIdを渡すとコンパイルエラー
processCustomerId orderId
```
Goの場合
```Go
type CustomerId int
type OrderId int

func main() {
	var orderId OrderId = 1
	processCustomerId(orderId) // OrderId型を渡しているためコンパイルエラー
}

func processCustomerId(customerId CustomerId) {
	// 何かしらの処理
}
```
#### 単一ケース共用体を分解（アンラップ）
F#の場合
```F#
// 構築
let customerId = CustomerId 42

// 分解：innterValueに42がセットされる
let (CustomerId innerValue) = customerId
printfn "%i" innerValue // 42が出力される
```
Goの場合
```Go
var customerId CustomerId = 42

// customerIdをintでキャストする
innerValue := int(customerId)
fmt.Println(innerValue)
```
補足：インターフェースの型で動的に処理を変える時は、型スイッチを使ってアンラップする認識です

#### 5.3.2 制約された値
- 単純型
	- ほとんどの場合なんらかの制約がある
		- 特定の範囲内にあること
		- 特定のパターンに一致していること

→ 実世界のドメインでは、境界のない整数や文字列が存在することは非常に稀

#### 5.3.3 単純型によるパフォーマンス問題の回避

- F#の単純型
	- メリット：型安全性を確保し、コンパイル時のエラーを防げる
	- デメリット：実行時に型情報が必要なためメモリ使用量と効率性の犠牲

よいとこ取りする方法として３つある
#### 型エイリアス
新しい型を作るわけではなく別名をつけるだけなのでオーバーヘッドはないが、型安全性は下がる<br>
※Goの場合、実行時に型情報は不要のため型定義と型エイリアスにメモリのオーバーヘッドの差分はない
```Go
type CustomerId = int
type OrderId = int

var customerId CustomerId = 42
var orderId OrderId = customerId //int型なのでエラーにならない
```
#### 構造体
F#では参照型ではなく、値型（構造体）を使用できる。ラッパーによるオーバーヘッドはあるが、配列格納時は連続したメモリ領域が使用されることでキャッシュ効率がよくなる
```Go
type UnitQuantity struct {
	Value int
}
```
#### 大きな配列を扱う
単純型のコレクションではなく、プリミティブ値のコレクション全体を1つの型として扱う
```Go
// 型定義 → 型に意味を持たせる
type UnitQuantities []int

// 構造体でラップ → 型としてのふるまいを持たせる
type UnitQuantities struct {
    Values []int
}
```

→ コードに反映する際は、まずはもっとも分かりやすい方法でドメインをモデル化し、そのあとでチューニングや最適化に取り組むのがベスト