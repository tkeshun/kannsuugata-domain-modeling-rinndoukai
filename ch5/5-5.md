# 5-5: 関数によるワークフローのモデリング

### 本節の目的
* ビジネスプロセスである「ワークフロー」を関数型としてモデリングできるようになる

```F#: 関数
type ValidateOrder = UnvalidatedOrder -> ValidatedOrder
```


## 5.5.1: 複雑な入力と出力の処理


### 出力 のモデリング

1. outputAとoutputBの両方（AND）を出力する場合<br>
（例）ワークフロー「注文確定」の図<br>
<br>
![](placedorderworkflow.drawio.svg)<br>
注文確定の出力は右の3つであり、全て出力をする必要がある<br>
　⇒　**複合型で表現**
    
    ```F#：全て出力する場合は複合型で表現
    type PlacedOrderEvents = {
        AcknowledgementSent : AcknowledgmentSent
        OrderPlaced : OrderPlaced
        BillableOrderPlaced : BillableOrderPlaced
    }
    ```
    
    ワークフローは以下のようになる<br>
    ```
    type PlaceOrder = UnvalidatedOrder -> PlaceOrderEvents
    ```

2. outputAとoutputBのどちらかを出力する場合<br>
<br>
(例)受信したメールを「注文」と「見積依頼」に仕分けるワークフロー<br>
<br>
![](categorizemail.drawio.svg)<br>
メール自体はどちらか一方であり、その後の処理はメールの種類によって決まる<br>
　⇒　**選択型で表現**

    ````
    type CategorizedMail =
      | Quote of QuoteForm
      | Order of OrderForm
    ````

    ワークフローは以下のようになる<br>
    ```
    type CategorizedInboundMail = EnvelopeContents -> Categorizedmail
    ```


### 入力 のモデリング
・ORの場合　⇒　選択型
・ANDの場合　⇒　複合型　or どちらも渡す
　・どちらを選択するか
　　・本当の入力ではなく「依存関係」となっている場合
　・複合型のメリット
　　・どちらも必須で入力され、互いに結びついている場合


## 5.5.2: 関数のシグネチャでエフェクトを文書化する
・先ほどの注文は検証が必ず成功する前提で作成されていた
・実際は失敗することもあり、それを明示的に表現したい
　⇒　Result型を作成する

```
type Validateorder =
UnvalidatedOrder -> Result<ValidatedOrder, ValidationError list>
```

関数型プログラミングでは、関数が主な出力以外に行ういことを**エフェクト**と呼ぶ。
Resultをつけることで、ValidateOrderが「エラーエフェクト」を持つ可能性があるということを表現できた。

同様に、「非同期エフェクト」も以下のように書くことができる

```
type ValidateOrder = Async<Result<ValidatedOrder, ValidationError list>>
```

ただ、これだと分かりづらいので、型のエイリアスを使って見た目を整える

```
type ValidationResponse<'a> = Async<Result<'a, ValidationError list>>
```
そうすると、以下のように表すことができる

```
type ValidateOrder = UnvalidatedOrder -> ValidationResponse<ValidatedOrder>
```
