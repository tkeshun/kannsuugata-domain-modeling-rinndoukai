# 5-5: 関数によるワークフローのモデリング

### 本節の目的
* ビジネスプロセスである「ワークフロー」を関数型としてモデリングできるようになる

```Go
func placeOrder(unvalidatedOrder UnvalidatedOrder) ValidatedOrder {
    // なんか処理
}
```


## 5.5.1: 複雑な入力と出力の処理


### 出力 のモデリング

#### 1. outputAとoutputBの両方（AND）を出力する場合<br>
（例）ワークフロー「注文確定」の図<br>
<br>

![](./image/placedorderworkflow.drawio.svg)

注文確定の出力は右の3つであり、全て出力をする必要がある<br>
　⇒　**複合型で表現**

```Go
// 複合型を定義
type PlacedOrderEvents struct {
    AcknowledgementSent AcknowledgmentSent
    OrderPlaced OrderPlaced
    BillableOrderPlaced BillableOrderPlaced
}

// ワークフローは以下のようにあらわすことができる
func placeOrder(uo UnvalidatedOrder) PlaceOrderEvents {
    val acknowledgementSent AcknowledgementSent = AcknowledgementSent{~~}
    val orderPlaced OrderPlaced = AcknowledgementSent{~~}
    val billableOrderPlaced BillableOrderPlaced = AcknowledgementSent{~~}

    return PlaceOrderEvents{
        AcknowledgementSent: acknowledgementSent
        OrderPlaced: orderPlaced
        BillableOrderPlaced: billableOrderPlaced
    }
}
```

#### 2. outputAとoutputBのどちらか（OR）を出力する場合<br>
<br>
(例)受信したメールを「注文」と「見積依頼」に仕分けるワークフロー<br>
<br>

![](image/categorizemail.drawio.svg)<br>

メール自体はどちらか一方であり、その後の処理はメールの種類によって決まる<br>
　⇒　**選択型で表現**

```Go
type CategorizedMail interface {
    GetContent() string
}

type QuoteForm struct {
    Content string
    From string
    To string
}

func (q QuoteForm) GetContent() string {
    return q.Content
}

type OrderForm struct {
    Content string
    From string
    To string
}

func (o OrderForm) GetContent() string {
    return o.Content
}

func categorizedInboundMail(EnvelopeContents string) Categorizedmail {
    // switch文で
}
```


### 入力 のモデリング
* ORの場合　⇒　選択型
  * どちらも必須で入力され、互いに結びついている場合に利用する
* ANDの場合　⇒　複合型　or どちらも渡す
  * 本当の入力ではなく「依存関係」となっている場合に利用する


## 5.5.2: 関数のシグネチャでエフェクトを文書化する
先ほどの注文は検証が必ず成功する前提で作成されていたが、実際は失敗することもあり、それを明示的に表現したい。
　⇒　Result型を作成する

* F#
```F#
type Validateorder =
UnvalidatedOrder -> Result<ValidatedOrder, ValidationError list>
```
* Go
```Go
validateOrder := func(uo UnvalidatedOrder) (ValidatedOrder, []ValidationError) {
    var errors []ValidationError
    var v ValidatedOrder

    if unValid(uo) {
	    errors = append(errors, ValidationError{"エラー"})
    } else {
        v = ValidatedOrder{}
    }
    return v, errors
}
```

> [!TIP]
> 関数型プログラミングでは、関数が主な出力以外に行ういことを**エフェクト**と呼ぶ
