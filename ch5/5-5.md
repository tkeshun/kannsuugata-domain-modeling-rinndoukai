# 5-5: 関数によるワークフローのモデリング

### 本節の目的
* ビジネスプロセスである「ワークフロー」を関数型としてモデリングできるようになる

```F#: 関数
type ValidateOrder = UnvalidatedOrder -> ValidatedOrder
```


## 5.5.1: 複雑な入力と出力の処理


### 出力 のモデリング

#### 1. outputAとoutputBの両方（AND）を出力する場合<br>
（例）ワークフロー「注文確定」の図<br>
<br>

![](./image/placedorderworkflow.drawio.svg)

注文確定の出力は右の3つであり、全て出力をする必要がある<br>
　⇒　**複合型で表現**

```
type PlacedOrderEvents = {
    AcknowledgementSent : AcknowledgmentSent
    OrderPlaced : OrderPlaced
    BillableOrderPlaced : BillableOrderPlaced
}
```
    
ワークフローは以下のようになる<br>
```
type PlaceOrder = UnvalidatedOrder -> PlaceOrderEvents
```

#### 2. outputAとoutputBのどちらか（OR）を出力する場合<br>
<br>
(例)受信したメールを「注文」と「見積依頼」に仕分けるワークフロー<br>
<br>

![](image/categorizemail.drawio.svg)<br>

メール自体はどちらか一方であり、その後の処理はメールの種類によって決まる<br>
　⇒　**選択型で表現**

```
type CategorizedMail =
  | Quote of QuoteForm
  | Order of OrderForm
````

ワークフローは以下のようになる<br>
```
type CategorizedInboundMail = EnvelopeContents -> Categorizedmail
```


### 入力 のモデリング
* ORの場合　⇒　選択型
  * どちらも必須で入力され、互いに結びついている場合に利用する
* ANDの場合　⇒　複合型　or どちらも渡す
  * 本当の入力ではなく「依存関係」となっている場合に利用する


## 5.5.2: 関数のシグネチャでエフェクトを文書化する
先ほどの注文は検証が必ず成功する前提で作成されていたが、実際は失敗することもあり、それを明示的に表現したい。
　⇒　Result型を作成する

```
type Validateorder =
UnvalidatedOrder -> Result<ValidatedOrder, ValidationError list>
```

> [!TIP]
> 関数型プログラミングでは、関数が主な出力以外に行ういことを**エフェクト**と呼ぶ


「非同期エフェクト」も以下のように書くことができる
```
type ValidateOrder = Async<Result<ValidatedOrder, ValidationError list>>
```

> [!TIP]
> ネストが深い場合はエイリアスを用いてスッキリさせることも可能
>```
>type ValidationResponse<'a> = Async<Result<'a, ValidationError list>>
>
>type ValidateOrder = UnvalidatedOrder -> ValidationResponse<ValidatedOrder>
>```
