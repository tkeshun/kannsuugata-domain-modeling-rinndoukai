# 5.8 集約
- Order はエンティティ（＝データが時間とともに変化する）
- OrderLine もエンティティ
- Order は複数の OrderLine を含む

では、OrderLine を変更したら Order も変更されたことになるか？  
⇒ ✅️ YES
不変のデータ構造の場合、以下の両方のコピーを作る必要がある
- 変更する OrderLine 自身
- 変更する OrderLine を含む Order

```go
func changeOrderLinePrice(order Order, orderLineId OrderLineId, newPrice Price) Order {
	orderLine := findOrderLine(order.OrderLines, orderLineId)

	newOrderLine := orderLine
	newOrderLine.Price = newPrice

	newOrderLines := replaceOrderLine(order.OrderLines, orderLineId, newOrderLine)

	newOrder := order
	newOrder.OrderLines = newOrderLines

	return newOrder
}
```

低レベルのコンポーネント (OrderLine) を変更すると、高レベルのコンポーネント (Order) も変更が加わる。
このような関係にあるエンティティの集合を**集約**といい、トップレベルのエンティティを**集約ルート**という。

## 5.8.1 集約による整合性と不変条件の担保
集約はデータの更新時に重要。

集約のある部分が更新される ⇒ 整合性を保つために他の部分も更新が必要

例）Order が合計金額を持っている場合  
明細の金額が更新される ⇒ 合計金額も更新が必要

集約は不変条件が適用される場所でもある。

例）「注文には少なくとも1つの明細行がある」というルールがある場合  
明細が1行しかないときにそれを削除しようとする ⇒ エラーを発生

## 5.8.2 集約の参照
注文がどの顧客のものかの情報を持たせる場合

- ❌️NG例
  ```go
  type Order struct {
      OrderId OrderId
      Customer Customer // Customer をフィールドに追加
      OrderLines []OrderLine
      // ...
  }
  ```
  - Customer が変更されたら Order も変更される？
- ✅️よい例
  ```go
  type Order struct {
      OrderId OrderId
      CustomerId CustomerId // CustomerId をフィールドに追加
      OrderLines []OrderLine
      // ...
  }
  ```
  - IDを通して顧客への参照を持つ
  - 顧客の情報が必要になったら、CustomerIdを使ってデータベースから取得

- Customer と Order は異なる独立した集約
  - 集約ルートのオブジェクトのIDを通してのみつながる
- 集約は永続化の基本単位でもある
  - データベースから取得 / 保存するときは集約全体で
  - トランザクションは単一の集約のみを扱う
  - ネットワーク経由での送信も集約全体を        

> [!NOTE]
> 集約の役割
> - トップレベルのエンティティが「ルート」として機能する、単一のユニットとして扱えるドメインオブジェクトのコレクション
> - 集約内のオブジェクトに対するすべての変更は、集約ルートを起点にする必要がある
>   - 集約内のすべてのデータが同時に正しく更新されることを保証する
> - 永続化、データベーストランザクション、データ転送におけるアトミックな処理単位

集約を定義することは、設計プロセスの重要な部分。
エンティティ間の関係や整合性の境界を理解しているのはドメインエキスパート。