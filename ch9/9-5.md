## 9.5 パイプラインのステップを1つに合成する

#### サマリー

形の異なる関数の合成（7.6）、および部分適用（8.2.5）の実例

※ Goではパイプを表現できない（前回今本さんから紹介があったComposeでの代用も冗長）ので、Goへの置き換えはスキップします

#### パイプ接続の課題

前章までのロジックをパイプで接続すると、入力に課題が発生

```fsharp
let placeOrder : PlaceOrderWorkflow =
  fun unvalidatedOrder ->
    unvalidatedOrder
    // 課題: UnvalidatedOrderの他に、CheckProductCodeExisrts, CheckAddressExistsの入力が必要
    |> validateOrder
    // 課題: ValidateOrderの他に、GetProductPriceの入力が必要
    |> priceOrder 
    |> acknowledgeOrder
    |> createEvents
```

#### 解決策

部分適用を用いて依存関係を組み込んだ（=一部の入力を別途注入した）関数を定義

```fsharp
let placeOrder : PlaceOrderWorkflow =
    // FYI: F#では局所的な同盟関数を定義可能（シャドーイング）
    let validateOrder =
        validatedOrder checkProductCodeExists checkAddressExists
    let pricedOrder =
        priceOrder getProductPrice
    let acknowledgementOption =
        acknowledgeOrder createAcknowledgementLetter sendAcknowledgment
    
    // ↑で部分適用した関数のおかげでパイプとして接続できるようになる
    fun unvalidatedOrder ->
        unvalidatedOrder
        |> validateOrder
        |> priceOrder 
        |> acknowledgeOrder
        |> createEvents
```

<details><summary>別解</summary>

```fsharp
let placeOrder : PlaceOrderWorkflow =
  fun unvalidatedOrder ->
    let validateOrder =
      unvalidatedOrder
      |> validatedOrder checkProductCodeExists checkAddressExists
    let pricedOrder =
      validatedOrder
      |> priceOrder getProductPrice
    let acknowledgementOption =
      pricedOrder
      |> acknowledgeOrder createAcknowledgementLetter sendAcknowledgment
    let events =
      createEvents pricedOrder acknowledgementOption    
    events
```

</details>

##### 残課題

組み込む依存関係はどこで定義する ？（次で解説）

##### 所管（≒まとめ）

- 部分適用の実例を説明
- パイプ（ただ順番に関数を接続していくだけ）ではなかなか実務では使えない
  - 次以降で引き続き説明