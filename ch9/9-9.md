## 9.9 まとめ

本章ではパイプラインの各ステップの実装と依存関係の処理に焦点を当てた

- 各ステップの実装について
  - 1 つのインクリメンタルな変換に焦点を絞っている
    - インクリメンタルな変換 = 小さく段階的な変換
  - これにより単独で理解しやすく、テストも容易になる
- 各ステップの合成の際に型が一致しない場合のテクニック

  1. アダプター関数
     <details>
     <summary>Goでの実装例</summary>

     ```go
     package main

     import (
         "errors"
         "fmt"
     )

     type ProductCode string

     func CheckProductCodeExists(productCode ProductCode) bool {
         return productCode == ProductCode("W")
     }

     func predicateToPassthru[T any](errorMsg string, f func(T) bool) func(T) (T, error) {
         return func(x T) (T, error) {
             if f(x) {
                 return x, nil
             }
             return x, errors.New(errorMsg)
         }
     }

     func main() {
         toProductCode := predicateToPassthru("Product doesn't exist", CheckProductCodeExists)

         result, err := toProductCode(ProductCode("W"))

         fmt.Printf("'%s':%v\n", result, err)
     }

     ```

     </details>

  2. 共通の型に持ち上げる
     - Option 型 -> 空の list へ変換する
     - 次の章でも解説がありそう
  3. 部分適用を使用して不要な実装の詳細を隠す
     <details>
     <summary>Goでの実装例</summary>

     ```go
     package main

     import (
         "errors"
         "fmt"
     )

     type ProductCode string

     type CheckProductCodeExists func(ProductCode) bool

     func predicateToPassthru[T any](errorMsg string, f func(T) bool) func(T) (T, error) {
         return func(x T) (T, error) {
             if f(x) {
                 return x, nil
             }
             return x, errors.New(errorMsg)
         }
     }

     // カリー化
     func toProductCode(checkProductCodeExists CheckProductCodeExists) func(string) (ProductCode, error) {
         errorMsg := "Product doesn't exist"
         checkProductCode := predicateToPassthru(errorMsg, checkProductCodeExists)

         return func(code string) (ProductCode, error) {
             pc := ProductCode(code)
             return checkProductCode(pc)
         }
     }

     // テスト

     func CanConvertToProductCodeTest() {
         validate := func(pc ProductCode) bool {
             return true
         }
         convert := toProductCode(validate) // 依存関係を部分適用

         result, err := convert("X") // 依存関係を隠して呼び出せる

         if (err == nil) {
             fmt.Printf("OK: '%s'\n", result)
         } else {
             fmt.Printf("NG: expected no error")
         }
     }

     func CannotConvertToProductCodeTest() {
         validate := func(pc ProductCode) bool {
             return false
         }
         convert := toProductCode(validate) // 依存関係を部分適用

         result, err := convert("X")// 依存関係を隠して呼び出せる

         if (err != nil) {
             fmt.Printf("OK: '%s'\n", err)
         } else {
             fmt.Printf("NG: expected has error '%s'\n", result)
         }
     }

     func main() {
         CanConvertToProductCodeTest()
         CannotConvertToProductCodeTest()
     }

     ```

次の章では、関数の型に Result 型を戻し、その取り扱いについて学ぶ

- エフェクトの処理を避ける（例外を使う）ことは関数合成においては便利
- ただしドキュメント管理の観点では最悪
  - ごまかしのある関数シグネチャになっている
