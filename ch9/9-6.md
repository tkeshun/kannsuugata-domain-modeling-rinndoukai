## 9.6 依存関係の注入

#### サマリー

9.5の残課題となっていた、依存をどのように注入するかを実例を使って解説

#### 前提

* 関数型プログラミングでは依存関係が暗黙的になるのは好ましくない
    * オブジェクト指向でのコンテナなど
* 関数型プログラミングではモナドを使用した手法があるが入門向けではない
    * 本書ではトップレベルの関数からひたすら入力として引き回す方法を紹介
* 依存関係を設定するトップレベルの関数を「コンポジションルート」と呼ぶ
    * できるだけアプリケーションのエントリーポイントに近いものにすべき

#### 依存関係を注入する実例

9.5の例で使用したplaceOrderに依存関係を注入する方法を考える
↓で外から依存を注入できている状態

```fsharp
let placeOrder
    // 5つの依存を持つ
    checkProductCodeExists
    checkAddressExists
    getProductPrice
    createAcknowledgementLetter
    sendAcknowledgment
     : PlaceOrderWorkflow =
    
    let validateOrder =
        validatedOrder checkProductCodeExists checkAddressExists
    let pricedOrder =
        priceOrder getProductPrice
    let acknowledgementOption =
        acknowledgeOrder createAcknowledgementLetter sendAcknowledgment
    
    fun unvalidatedOrder ->
        unvalidatedOrder
        |> validateOrder
        |> priceOrder 
        |> acknowledgeOrder
        |> createEvents
```

#### 9.6.1 依存関係が多すぎる？

上の例では5つの依存があり辛い。また、子関数の中で更なる依存が発生した場合は芋づる式に親から引き回す必要があって辛い

* 対策
    1. もっと小さな関数に分割できないか
    2. 依存を1つのパラメータにまとめる（低レベルの関数をあらかじめ定義しておき、利用する）

validateOrderの例（今まではplaceOrderの話をしていたのに急に中間関数の話になる）

```fsharp
let validateOrder
    checkProductCodeExists
    checkAddressExists
    endPoint // checkAddressExistsでのみ必要
    credentials // checkAddressExistsでのみ必要
    unvalidatedOrder
    ...
```

```fsharp
let placeOrder : PlaceOrderWorkflow =

    ...

    let endPoint = ...
    let credentials = ...
    
    let checkProductCodeExists = checkAddressExists endPoint credentials
    
    ...
    
    // FYI: validateOrder目線ではendPointやcredentialsを意識しないでよくなるよねっていう話だと理解
    let validateOrder =
        validatedOrder checkProductCodeExists checkAddressExists
    ...
```

##### 所管（≒まとめ）

* 「関数型プログラミングでは依存関係が暗黙的になるのは好ましくない」なぜ？
    *  副作用とかと同じで、関数内での意図しない操作を嫌う？
* できるだけ関数は小さく
* 原則的にはトップレベルで依存を定義して引き回すが、スコープ（関数の関心ごと）にあわせてパラメータを抽象化する