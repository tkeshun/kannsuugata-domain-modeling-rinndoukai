## 4.6 省略可能な値、エラー、およびコレクションのモデリング


### 4.6.1 省略可能な値のモデリング

* `F#`ではレコード型などの値にnullにできない
* 代わりに`option`型を使う
* 標準型として`Option`型があるが定義すると下記のようになる

```F#
type Option<`a> = Some of `a | None
```

```F#
type PersonalName = {
    FirstName: string
    MiddleName: string option
    LastName: string
}
```

* goには`Option`型がないので、ポインタ型を使う
* (nullを許容したいだけのために下記は過剰かも...)

```go
package main
type Option[T any] struct {
	Value *T
}

func Some[T any](v T) Option[T] {
	return Option[T]{Value: &v}
}
func None[T any]() Option[T] {
	return Option[T]{Value: nil}
}

```

```go
package main

type PersonalName struct {
	FirstName  string
	MiddleName *string // Option型の代わり
	LastName   string
}
```

### 4.6.2 エラーのモデリング

* 「支払いは、成功したか、カードの有効期限切れで失われたかのどちらかです。」をモデリングする
* 明示的に失敗を表す型を定義する

```F#
type Result<'Success, 'Failure> = Ok of 'Success | Error of 'Failure
```

```F#
type PayInvoice = UnpaidInvoice -> Payment -> Result<PaidInvoice, PaymentError>
type PaymentError = CardTypeNotRecognized | PaymentRejected | PaymentProviderOffline
```

* Goではタプル `((T, error))` を使うっぽい

```go
package main
import "fmt"

type UnpaidInvoice struct{}
type PaidInvoice struct{}
type Payment struct{}

func PayInvoice(inv UnpaidInvoice, p Payment) (PaidInvoice, error) {
	if p.Method == nil {
		return PaidInvoice{}, fmt.Errorf("payment method not recognized")
	}
	return PaidInvoice{}, nil
}

func main() {
	invoice := UnpaidInvoice{}
	paidInvoice, err := PayInvoice(invoice, payment)
	if err != nil {
		fmt.Println("Payment failed:", err)
	} else {
		fmt.Println("Payment successful:", paidInvoice)
	}
}
```

### 4.6.3 値が存在しないことのモデリング

* ほとんどの言語に値を返さない`void`のような概念がある
* `F#`などの関数型では**必ず何かを返す**必要があるため`void`は使えない
* 代わりに`unit`型を使う
* DBの永続化など、副作用がある場合に使う

```F#
// 出力がない関数
type SaveCustomer = Customer -> unit
// 入力がない関数
type NextRandom = unit -> int
```

* Goでは入力/出力を指定しないことができる

```go
package main
// 出力がない関数
func SaveCustomer(c Customer) {}
// 入力がない関数
func NextRandom() int {}
```

### 4.6.4 リストとコレクションのモデリング

* `list`: 固定サイズの不変コレクション
* `array`: 固定サイズの可変コレクション
* `ResizeArray`: 可変サイズの可変コレクション
* `seq`: 遅延評価されるシーケンス
* `Map`/`Set`: キー/値のペアを格納するコレクション


go言語の場合は

* `list`: `[]T` で表現。ただし、Go では copy() を使えば不変に可能
* `array`:  `[N]T`（固定長）
* `ResizeArray`: `[]T` で `append()` を使うことで可変
* `seq`: `chan T` を使って遅延評価を実現
* `Map`: `map[K]V`

リストを分解してその中の要素にアクセスする場合

```F#
let printList aList =
    match aList with
    | [] -> printfn "list is empty"
    | [x] -> printfn "list has one element: %A" x
    | [x; y] -> printfn "list has two elements: %A and %A" x y
    | longerList -> printfn "list has more than two elements"
```

```go
package main
import "fmt"

func PrintList(aList []int) {
	switch len(aList) {
	case 0:
		fmt.Println("list is empty")
	case 1:
		fmt.Printf("list has one element: %v\n", aList[0])
	case 2:
		fmt.Printf("list has two elements: %v and %v\n", aList[0], aList[1])
	default:
		fmt.Println("list has more than two elements")
	}
```
