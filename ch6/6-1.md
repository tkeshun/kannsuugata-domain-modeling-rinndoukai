# 6章 ドメインの中の完全性と一貫性
この章では整合性と一貫性のモデリングについて説明します

すべてのデータ値が常に有効であることを確実にできれば、実装はクリーンな状態を保つことができ、防御的なコーディングを行う必要がなくなります

このコンテキストでの整合性とは、
データが正しいビジネスルールに従っていることを意味します

### 整合性の例
- UnitQuantity は 1 から 1000 の間である
- 注文には常に少なくとも 1 つの注文明細が必要
- 注文は配送部門に送られる前に、検証済みの配送先住所を持っている

コード内でこれを複数回確認することなく常に正しいと信頼できる状態にしたい

ここでの一貫性とは、ドメインモデルのさまざまな部分が事実と一致していることを意味します

### 一貫性の例
- 注文に対して請求される合計金額は、個々の明細の合計である
  - 合計が異なる場合、データに矛盾がある
- 注文が行われると対応する請求書を作成する
  - 注文は存在するが請求書が存在しない場合データに矛盾がある
- 注文で割引バウチャーコードを使用する場合、そのバウチャーコードは使用済みとしてマークされ、再度使用できなくなる
  - 注文でそのバウチャーが参照されているのに、そのバウチャーが使用済みとしてマークされていない場合、データは不整合です

常にそうですが、型システムにより多くの情報を取り込めば取り込むほど、必要なドキュメントが減り、コードが正しく実装される可能性が高くなります。


## 単純な値の完全性

5-3章で、単純な値は文字列や int ではなく、WidgetCode や UnitQuantity などのドメインに重点を置いた型で表すべきだと説明しました
しかし実際のドメインでは、ほとんどの場合何らかの形で制約があります

- OrderQuantity 
  - 符号付き整数で定義されていても、ビジネスで負の値や 40 億になることはほとんどない
  - 1 から 1000 までの範囲
- CustomerName 
  - string で定義されていても、タブ文字や改行は含めない
  - 文字列は特定の文字で始まる必要がある

こういったルールをコメントに書いて利用者に読んでもらうのではなく、
制約を満たさない限りこれらの型の値は作成できないようにする必要があります

```
type WidgetCode = WidgetCode of string   // starting with "W" then 4 digits
type UnitQuantity = UnitQuantity of int  // between 1 and 1000
type KilogramQuantity = KilogramQuantity of decimal // between 0.05 and 100.00
```

制約を適用するためには、プログラミング言語を問わず
プライベートなコンストラクタで有効な値を作成し、無効な値の場合はエラーを返すことで解決できます

作成後のデータは不変であるため、内部の値を再度チェックする必要はありません
防御的なコーディングを一切行う必要もなく、どこでも WidgetCode または UnitQuantity を自信を持って使用できます

FP コミュニティでは、これをスマート コンストラクター アプローチと呼ぶことがあります

```go
package main

import (
	"errors"
	"fmt"
)

// UnitQuantity is a private struct with an unexported field
type UnitQuantity struct {
	value int
}

// CreateUnitQuantity acts as a smart constructor
func CreateUnitQuantity(qty int) (UnitQuantity, error) {
	if qty < 1 {
		return UnitQuantity{}, errors.New("UnitQuantity can not be negative")
	}
	if qty > 1000 {
		return UnitQuantity{}, errors.New("UnitQuantity can not be more than 1000")
	}
	return UnitQuantity{value: qty}, nil
}

func main() {
	// Example usage
	qty, err := CreateUnitQuantity(500)
	if err != nil {
		fmt.Println("Error:", err)
	}
	fmt.Println("Created UnitQuantity with value:", qty.value)

	// Error case
	qty, err = CreateUnitQuantity(1500)
	if err != nil {
		fmt.Println("Error:", err)
	}
}
```