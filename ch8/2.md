## 8.2.1 「もの」 としての関数

関数を値としても考える

1. 関数は入力値になる
2. 関数は出力値になる
3. 関数は渡された先の関数の振る舞いを変えることができる ( 1.)

## 8.2.1 関数を「もの」として扱う

```go
package main

import (
	"fmt"
)

// main関数外で定義するなら
// func plus3 (x int) int {
//     return x + 3
// }

// func times2 (x int) int {
//     return x * 2
// }

func main() {

	plus3 := func(x int) int {
		return x + 3
	}

	times2 := func(x int) int {
		return x * 2
	}

	square := func(x int) int {
		return x * x
	}

	addThree := plus3

	listOfFunctions := []func(int) int{
		addThree,
		times2,
		square,
	}

	for _, fn := range listOfFunctions {
		result := fn(100)
		fmt.Printf("If 100 is the input, the output is %d\n", result)
	}
}
```


### 関数定義
```go
func square(x int) int {
	return x * x
}
```

### 変数に無名関数を代入
```go
square := func(x int) int {
	return x * x
}
```

## 8.2.2 入力としての関数


```go
package main

import (
	"fmt"
)

func main() {
	// 関数を引数に取る関数（高階関数）
	evalWith5ThenAdd2 := func(fn func(int) int) int {
		return fn(5) + 2
	}

	add1 := func(x int) int {
		return x + 1
	}
	fmt.Println(evalWith5ThenAdd2(add1))   // 出力: 8

	square := func(x int) int {
		return x * x
	}
	fmt.Println(evalWith5ThenAdd2(square)) // 出力: 27
}
```

## 8.2.3 出力としての関数

```go
package main

import (
	"fmt"
)

func main() {
    adderGenerator := func (numberToAdd int) func(int) int {
        return func (x int) int {
            return numberToAdd + x
        }
    }

    // こちらの書き方でも良い
    // adderGenerator := func(numberToAdd int) func(int) int {
	// 	innerFn := func(x int) int {
	// 		return numberToAdd + x
	// 	}
	// 	return innerFn
	// }
	add1 := adderGenerator(1)
	add100 := adderGenerator(100)

	fmt.Println(add1(2))    // 出力: 3
	fmt.Println(add100(2))  // 出力: 102
}
```

## 8.2.4 カリー化

```go
package main

import "fmt"

func main() {

	// カリー化されてない
	noCurriedAdd := func(x int, y int) int {
		return x + y
	}

	fmt.Println(noCurriedAdd(1, 2))
	// カリー化された
	add := func(x int) func(int) int {
		return func(y int) int {
			return x + y
		}

	}

	add1 := add(1)       // 1 を固定
	fmt.Println(add1(2)) // 3
    fmt.Println(add(1)(2)) // 3
}
```

```go
addWithCurried3Parameter := func(x int) func(int) func(int) int {
	// x をキャプチャして、次の関数を返す
	return func(y int) func(int) int {
		// y もキャプチャして、最終的な関数を返す
		return func(z int) int {
			// 実際の計算はここで起きる
			return x + y + z
		}
	}
}

result =  addWithCurried3Parameter(1)(2)(3)
```

### 読み方のイメージ

実行 -> 返り値
1. addWithCurried3Parameter(1) → func(y int) func(int) int
2. addWithCurried3Parameter(1)(2) → func(z int) int
3. addWithCurried3Parameter(1)(2)(3) → 1 + 2 + 3 = 6


## 8.2.5 部分適用

カリー化された関数に対して、
パラメータを部分的に適用していくこと

### カリー化していない場合 (Appendix)
```go
func sayGreeting(greeting, name string) {
	fmt.Printf("%s %s\n", greeting, name)
}
```

### カリー化した場合
```go
package main

import "fmt"

func sayGreeting(greeting string) func(string) {
	return func(name string) {
		fmt.Printf("%s %s\n", greeting, name)
	}
}

func main() {
	hello := sayGreeting("Hello")
	hello("Alex")   // Hello Alex

	sayGreeting("Goodbye")("Alex")  // Goodbye Alex
}
```

### カリー化されたもので部分適用

```go
package main

import "fmt"

// カリー化された関数：string -> (string -> void)
func sayGreeting(greeting string) func(string) {
	return func(name string) {
		fmt.Printf("%s %s\n", greeting, name)
	}
}

func main() {
	// 部分適用（関数を生成）
	sayHello := sayGreeting("Hello")
	sayGoodbye := sayGreeting("Goodbye")

	sayHello("Alex")     // Hello Alex
	sayGoodbye("Alex")   // Goodbye Alex
}
```
