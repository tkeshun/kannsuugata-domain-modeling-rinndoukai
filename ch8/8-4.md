# 8.4 関数合成
- 1つめの関数の出力を2つ目の関数の入力に繋げて関数を組み合わせることを**関数合成**という
- 関数合成の重要な一側面に **情報の隠蔽**がある
	- 途中の操作や入出力の型が隠蔽され、全体の入出力のみしか見えなくなる
## 8.4.1 F#における関数の合成
- F#では最初の関数の出力型と2番目の関数の入力型が一致していれば関数をくっつけることができる（**パイピング**)
- F#におけるパイピングの実装例
```fsharp
let add1 x = x + 1 // int -> int
let square x = x * x  // int -> int

let add1ThenSquare x = x |> add1 |> square

add1ThenSquare 5 // 結果は36
```
```fsharp
let isEven x = (x % 2) = 0 // int -> bool
let printBool x = sprintf "value is %b" // bool -> string

let isEventThenPrint x = x |> isEven |> printBool

isEventhenPrint 2 // 結果は "value is true"
```
- Goはデフォルトの関数合成機能はないのでCompose関数を自作
```go
package main

import "fmt"

func main() {
	fmt.Println(add1ThenSquare(5)) //結果は36
	fmt.Println(isEvenThenPrint(2)) // 結果は"value is true"
}

// 2つの関数を合成した関数を返却する関数
// 間でやり取りするT型が合成後の関数で隠蔽されている
func Compose[S, T, U any](f1 func(S) T, f2 func(T) U) func(S) U {
	return func(s S) U {
		t := f1(s)
		return f2(t)
	}
}

func add1(x int) int { return x + 1 }

func square(x int) int { return x * x }

func add1ThenSquare(x int) int {
	return Compose(add1, square)(x)
}

func isEven(x int) bool { return x%2 == 0 }

func printBool(x bool) string { return fmt.Sprintf("value is %v", x) }

func isEvenThenPrint(x int) string {
	return Compose(isEven, printBool)(x)
}
```
## 8.4.2 関数からアプリケーション全体を構築する
- 関数合成の原理を利用して、ボトムアップで完全なアプリケーションを構築する
- 構築イメージ
	- 最下層は**低レベル処理関数**
	- 複数の低レベル処理を合成して**サービス関数**を形成
	- 複数のサービス関数を合成して**ワークフロー**を形成
	- 複数のサービスを並列に合成し、入力に応じて特定のワークフローを呼び出す**コントローラ/ディスパッチャ**を作成することで、これらのワークフローからアプリケーションを構築できる
## 8.4.3 関数を合成する上での課題
- 一方の関数の出力がもう一方の関数の入力と一致しない場合
- よくあるケース：基礎となる型は合うけれど関数の「形式」が異なる
	- 例1：出力が`Option<int>`, 入力が`int`
	- 例2：出力が`int`, 入力が`Option<int>`
	- リスト, 成功/失敗のResult型, 非同期を扱う場合も発生する
- これらの関数を合成するための一般的なアプローチは「両サイドの最小公倍数に変換する」
	- 例：`int`と`Option<int>`の最小公倍数は`Option`型
		- `Some`を用いて出力を`Option<int>`に変換することで、2番目の関数の引数に渡すことができる
- F#のコード例
```fsharp
let add1 x = x + 1 // int -> int

let printOption x = 
  match x with
  | Some i -> printfn "The int is %i" i
  | None -> printfn "No value"

5 |> add1 |> Some |> printOption
```
- Goのコード例
```go
package main

import "fmt"

func main() {
	ComposeVoid3(add1, Some[int], printOption)(5)
	// 間のintを隠蔽する場合は以下
	ComposeVoid(Compose(add1, Some), printOption)(5)
}

// 2つの関数を合成した関数を返却する関数
func Compose[S, T, U any](f1 func(S) T, f2 func(T) U) func(S) U {
	return func(s S) U {
		t := f1(s)
		return f2(t)
	}
}

// 2つの関数を合成し、合成後の戻り値がない関数を返却する関数
func ComposeVoid[S, T any](f1 func(S) T, f2 func(T)) func(S) {
	return func(s S) {
		t := f1(s)
		f2(t)
	}
}

// 3つの関数を合成し、合成後の戻り値がない関数を返却する関数
func ComposeVoid3[S, T, U any](f1 func(S) T, f2 func(T) U, f3 func(U)) func(S) {
	return ComposeVoid(Compose(f1, f2), f3)
}

// Option型をInterfaceで定義
type Option[T any] interface {
	IsPresent() bool
	Get() T
}

// SomeとNoneをOption型のファクトリ関数として定義
func Some[T any](v T) Option[T] { return some[T]{Value: v} }
func None[T any]() Option[T]    { return none[T]{} }

type some[T any] struct{ Value T }

func (s some[T]) IsPresent() bool { return true }
func (s some[T]) Get() T          { return s.Value }

type none[T any] struct{}

func (n none[T]) IsPresent() bool { return false }
func (n none[T]) Get() T          { panic("Not Present Value!!") }

func add1(x int) int { return x + 1 }

func printOption(x Option[int]) {
	if x.IsPresent() {
		fmt.Printf("The int is %d\n", x.Get())
	} else {
		fmt.Println("No value")
	}
}
```
