# 8.3 全域関数
- 全域関数：取りうる入力全てについて、対応する出力が1つずつ決まるように設計された関数
	- なぜわざわざそんなことをするか？
		- すべてのエフェクトを型シグネチャで文書化して、できるだけ物事を明示的にしたい
- 「入力値で12を整数除算したで割った結果を返却する」関数`twelveDevidedBy`を例に説明
- 全域関数ではないパターン
	- 12÷0はできない
		- 適切に返却できる値がないので`panic`を発生させている
	- 引数として`0`を渡した時に対応する出力がないので全域関数ではない
```go
// 負の整数を考慮すると冗長なのでuintに勝手に変更
func twelveDividedBy(n uint) uint {
	switch n {
	case 6:
		return 2
	case 5:
		return 2
	case 4:
		return 3
	case 3:
		return 4
	case 2:
		return 6
	case 1:
		return 12
	case 0:
		panic("cannot divide by 0!!")
	}
	// 上記以外の値についても勝手に実装追加
	if n > 12 {
		return 0
	}
	return 1
}
```
- 全域関数にあたるパターン(1)
	- 入力値が制限された型(`NonZeroInteger`)を用意して不正な値である`0`を排除する
	- `NonZeroInteger`の入力に対し必ず`uint`を返却しているので全域関数
```go
// 負の整数を考慮すると冗長なのでuintに勝手に変更
// 簡単な形で書いているが、本来はNonZeroInteger型のpackageを分けてunexported(小文字はじまり)にしたりしないと直接触れてしまう
type NonZeroInteger uint

func NewNonZeroInteger(n uint) NonZeroInteger {
	if n == 0 {
		panic("cannot set 0!!")
	}
	return NonZeroInteger(n)
}

func twelveDividedBy(n NonZeroInteger) uint {
	switch n {
	case 6:
		return 2
	case 5:
		return 2
	case 4:
		return 3
	case 3:
		return 4
	case 2:
		return 6
	case 1:
		return 12
	}
	if n > 12 {
		return 0
	}
	return 1
}
```
- 全域関数にあたるパターン(2)
	- 有効な値と未定義の値のどちらかを返す関数にして出力を拡張する
	- 引数で`0`が渡されても未定義を表す値を返せれば良い
```go
// Option型をInterfaceで定義
type Option[T any] interface {
	IsPresent() bool
	Get() T
}

// SomeとNoneをOption型のファクトリ関数として定義
func Some[T any](v T) Option[T] { return some[T]{Value: v} }
func None[T any]() Option[T]    { return none[T]{} }

type some[T any] struct{ Value T }

func (s some[T]) IsPresent() bool { return true }
func (s some[T]) Get() T          { return s.Value }

type none[T any] struct{}

func (n none[T]) IsPresent() bool { return false }
func (n none[T]) Get() T          { panic("Not Present Value!!") }

// 負の整数を考慮すると冗長なのでuintに勝手に変更
func twelveDividedBy(n uint) Option[uint] {
	switch n {
	case 6:
		return Some[uint](2)
	case 5:
		return Some[uint](2)
	case 4:
		return Some[uint](3)
	case 3:
		return Some[uint](4)
	case 2:
		return Some[uint](6)
	case 1:
		return Some[uint](12)
	case 0:
		return None[uint]() // 引数が0の場合のみNoneを呼ぶ
	}
	if n > 12 {
		return Some[uint](0)
	}
	return Some[uint](1)
}
```
