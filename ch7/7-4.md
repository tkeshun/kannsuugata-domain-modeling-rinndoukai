## 7.4 型でワークフローの詳細部分をモデリングする

ステートマシンの状態遷移を構成する１ステップを、
入力と出力を持つ関数としてモデリングして実装

各プロセスに滲んでいる依存  
→同じく、関数としてモデリングして実装する

### 7.4.1 未検証→検証済の状態遷移を行うサブステップを関数にする

1. 入出力を文章化

   例）「注文の検証」ステップ

   入力：`UnvalidatedOrder`

   出力：`ValidatedOrder`/`ValidationError`


2. 依存関係も文章化

   関数化したいステップに依存関係が含まれる場合、こちらも同様に関数として扱えるようモデル化する（何の入出力が行われるか、シグネチャを定義しておく）

   例）「注文の検証」ステップが依存しているサブステップ「製品コードの存在チェック」のモデル化  
   入力：`ProductCode`  
   出力：`bool`  
   （関数型アーキテクチャでは関数も型なので、） 製品コードの存在チェックをする型がこれで完成


###  依存関係のモデル化を行うときの要点３つ：
- **7.4.1 要点１：依存関係からの出力は、注目中のステップ内で触らない**  
  というか、それを処理するための関数に辿り着くまで、その型のまま返し続ける。  
  例）依存「アドレスの存在チェック」を含む「注文の検証」ステップの場合
    - 出力：Result型
    - 出力の中身１：成功の型`CheckedAddress`
    - 出力の中身２：失敗の型`AddressValidateionError`

      「アドレスの存在チェック失敗」用のエラー画面へ遷移させる関数などのトップレベルにたどり着く前に上記の型を使った何らかの処理を行う＝汚染が起こる
      ※アドレス検証の失敗について、どんな風に返す・どんな風に扱うといった情報は、注目中のステップとは関係のない「詳細」にあたるため。

      なので、「注文の検証」ステップ`ValidationOrder`の出力には「ハンドリングが必要なResult型を含みます！」とだけ型で表現するように返す。次の関数でも、それを引き継ぎ続ける。

- **7.4.2 要点２：依存関係から詳細を持ってこないようにする**

  そもそも依存関係の型やその中の処理などの詳細は、後でインターフェースとして実装する予定だが、その実装者しか知らなくて良いような詳細は、依存先の中だけで留める。
  注目しているステップでは「詳細を依存先から持ってくる関数」を作ってそのシグネチャだけ受け取るようにする。

  例）「注文の価格計算」ステップが依存しているサブステップ「製品カタログからの情報取得」のモデル化

  ❌type IProductCatalog  
  ⭕️type GetProductPrice

  依存関係のモデル「製品カタログからの情報取得」から受け取る型シグネチャは、注目しているステップ「注文の価格計算」で必要な「製品の価格情報」だけを提供する関数にする。これにより、依存先の中だけで完結してほしい商品カタログという詳細を隠す(カプセル化？)

- **7.4.3 要点３：一旦、具体的な実装より入出力の型定義が優先**  
  理由としては、後から実装の詳細を決めるインターフェース同様に、(そういう風に切り離してるはずの)詳細はいつでも変更できるから。

  例）「注文の確認」ステップが依存しているサブステップ「注文確認書の送信(SendOrderAcknowledgement)」によって返るもののモデル化

  受注ワークフロー全体でやりたいこと：  
  注文確認書が送られたら、それを知らせるイベントへつなげたい

  「注文確認」ステップでやりたいこと：  
  - 注文確認イベントの結果を、次のイベントに繋げやすく関数で表現しておきたい  
  - 注文確認の副作用についても型シグネチャでわかりやすく表現しておきたい

> [!note]
> つまり、本ステップの出力について決めるべきは  
> ・「注文」を　送った/送れてない　の情報をどう持たせるか  
> ・「送った」場合に返すイベントの型定義

     ※なぜイベント型で返すか：
     ❌unitで返す：副作用があることしか分からない
     🔺boolで返す：何の真偽？これも情報が少なすぎる
     ⭕️イベント型で返す（このイベントも、入出力を定義しておく）

- **7.4.4 要点４：返すイベントが複数に分岐するかもしれない場合は、イベント型のリストで返す**

      ```go
      package main
    
      import "fmt"
    
      // インターフェースで共通型を定義
      type PlaceOrderEvent interface {
          EventName() string
      }
    
      // それぞれのイベントを構造体として定義
      type OrderPlaced struct{}
      type BillableOrderPlaced struct{}
      type OrderAcknowledgmentSent struct{}
    
      // EventName()で型識別？
      func (OrderPlaced) EventName() string               { return "OrderPlaced" }
      func (BillableOrderPlaced) EventName() string       { return "BillableOrderPlaced" }
      func (OrderAcknowledgmentSent) EventName() string   { return "AcknowledgmentSent" }
    
      func main() {
          // イベント型のリスト
          events := []PlaceOrderEvent{
              OrderPlaced{},
              BillableOrderPlaced{},
              OrderAcknowledgmentSent{},
          }
        
          // 注文確認の結果をPlaceOrderEvent型で返す
      }
      ```
